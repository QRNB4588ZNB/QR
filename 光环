
local Players = game:GetService("Players")
local RS = game:GetService("RunService")
local workspace = game:GetService("Workspace")
local Debris = game:GetService("Debris")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")

local lp = Players.LocalPlayer
local char = lp.Character or lp.CharacterAdded:Wait()
local root = char:WaitForChild("HumanoidRootPart")
local humanoid = char:WaitForChild("Humanoid")

-- ==================== é…ç½®åŒºåŸŸ ====================
-- å…¨å±€é»˜è®¤è®¾ç½®ï¼ˆå¦‚æœæ­¦å™¨æ²¡æœ‰å•ç‹¬è®¾ç½®ï¼Œåˆ™ä½¿ç”¨è¿™äº›å€¼ï¼‰
local GLOBAL_DEFAULTS = {
    ATTACK_RANGE = 17,
    AIM_RANGE = 17,
    MAX_TARGETS_PER_CYCLE = 5,
    INSTANT_ATTACK_RATE = 0.005,
    HITS_PER_ATTACK = 2,
    BARREL_PRIORITY_RANGE = 17,
    TROLL_MODE_RANGE = 7
}

local MAX_DISPLAY_DISTANCE = 1000

local LABEL_SETTINGS = {
    Size = UDim2.new(0, 120, 0, 30),
    StudsOffset = Vector3.new(0, -2, 0),
    TextSize = 10,
}

local OUTLINE_SETTINGS = {
    Transparency = 1,                   
    Material = Enum.Material.Neon,         
    ColorMultiplier = 1.2,                 
    SizeMultiplier = 1.1,                  
}

-- ==================== æ–°å¢çš„ getNil å‡½æ•° ====================
local function getNil(name, class)
    for _, v in next, getnilinstances() do
        if v.ClassName == class and v.Name == name then
            return v
        end
    end
    return nil
end

-- ==================== æ­¦å™¨é…ç½®ï¼ˆæ¯ä¸ªæ­¦å™¨å•ç‹¬è®¾ç½®ï¼‰ ====================
-- æ ¼å¼ï¼šæ­¦å™¨åç§° = {é…ç½®é¡¹}
local weapons = {
    ["Voivode"] = {
        remotePath = "RemoteEvent", 
        attackType = "Thrust", 
        weaponType = "sword", 
        attackCount = 1,
        -- å•ç‹¬çš„æ”»å‡»å‚æ•°
        attackRange = 17,              -- æ”»å‡»èŒƒå›´
        aimRange = 17,                 -- ç„å‡†èŒƒå›´
        maxTargetsPerCycle = 4,        -- æ¯å‘¨æœŸç›®æ ‡æ•°
        instantAttackRate = 0.005,     -- æ”»å‡»é¢‘ç‡
        hitsPerAttack = 2,             -- æ¯æ¬¡æ”»å‡»è¿ç»­æ”»å‡»æ¬¡æ•°
        barrelPriorityRange = 17       -- è‡ªçˆ†ä¼˜å…ˆæ”»å‡»èŒƒå›´
    },
    
    ["Axe"] = {
        remotePath = "RemoteEvent", 
        attackType = "Side", 
        weaponType = "axe", 
        attackCount = 1,
        -- å•ç‹¬çš„æ”»å‡»å‚æ•°
        attackRange = 16,              -- æ”»å‡»èŒƒå›´
        aimRange = 16,                 -- ç„å‡†èŒƒå›´
        maxTargetsPerCycle = 3,        -- æ¯å‘¨æœŸç›®æ ‡æ•°
        instantAttackRate = 0.006,     -- æ”»å‡»é¢‘ç‡
        hitsPerAttack = 1,             -- æ¯æ¬¡æ”»å‡»è¿ç»­æ”»å‡»æ¬¡æ•°
        barrelPriorityRange = 16       -- è‡ªçˆ†ä¼˜å…ˆæ”»å‡»èŒƒå›´
    },
    
    ["Spontoon"] = {
        remotePath = "RemoteEvent", 
        attackType = "Thrust", 
        weaponType = "spear", 
        attackCount = 2,
        -- å•ç‹¬çš„æ”»å‡»å‚æ•°
        attackRange = 18,              -- æ”»å‡»èŒƒå›´
        aimRange = 18,                 -- ç„å‡†èŒƒå›´
        maxTargetsPerCycle = 6,        -- æ¯å‘¨æœŸç›®æ ‡æ•°
        instantAttackRate = 0.004,     -- æ”»å‡»é¢‘ç‡
        hitsPerAttack = 2,             -- æ¯æ¬¡æ”»å‡»è¿ç»­æ”»å‡»æ¬¡æ•°
        barrelPriorityRange = 18       -- è‡ªçˆ†ä¼˜å…ˆæ”»å‡»èŒƒå›´
    },
    
    ["Boarding Axe"] = {
        remotePath = "RemoteEvent", 
        attackType = "Thrust", 
        weaponType = "axe", 
        attackCount = 1,
        -- å•ç‹¬çš„æ”»å‡»å‚æ•°
        attackRange = 15,              -- æ”»å‡»èŒƒå›´
        aimRange = 15,                 -- ç„å‡†èŒƒå›´
        maxTargetsPerCycle = 4,        -- æ¯å‘¨æœŸç›®æ ‡æ•°
        instantAttackRate = 0.005,     -- æ”»å‡»é¢‘ç‡
        hitsPerAttack = 1,             -- æ¯æ¬¡æ”»å‡»è¿ç»­æ”»å‡»æ¬¡æ•°
        barrelPriorityRange = 15       -- è‡ªçˆ†ä¼˜å…ˆæ”»å‡»èŒƒå›´
    }
}

-- ==================== åƒµå°¸é…ç½® ====================
local zombieTypes = {
    ["Normal"] = {name = "åƒµå°¸", color = Color3.fromRGB(0, 255, 0), attack = true, priority = 1},
    ["Barrel"] = {name = "è‡ªçˆ†ç‹ğŸ¤¬", color = Color3.fromRGB(255, 255, 0), attack = true, priority = 3},
    ["Fast"] = {name = "çº¢çœ¼ğŸ˜ˆ", color = Color3.fromRGB(255, 0, 0), attack = true, priority = 2},
    ["Igniter"] = {name = "è€çƒ§ç‹ğŸ˜¡", color = Color3.fromRGB(255, 165, 0), attack = true, priority = 2},
    ["Sapper"] = {name = "å¤§å¸ˆå…„ğŸ˜¡", color = Color3.fromRGB(128, 0, 128), attack = true, priority = 2}
}

local zombieFolders = {"Zombies"}
local zombieBodyParts = {"Head", "HumanoidRootPart", "UpperTorso", "Torso", "LowerTorso",
                         "RightUpperArm", "RightLowerArm", "RightHand", "LeftUpperArm", "LeftLowerArm", "LeftHand",
                         "RightUpperLeg", "RightLowerLeg", "RightFoot", "LeftUpperLeg", "LeftLowerLeg", "LeftFoot",
                         "Agent.L", "Agent.R", "Agent.LA", "Agent.RA", "Left Leg", "Right Leg", "Left Arm", "Right Arm",
                         "Neck", "Waist", "Hip"}

-- ==================== ç³»ç»Ÿå˜é‡ ====================
local currentWeapon, currentWeaponConfig
local isWeaponActuallyEquipped = false 
local attackCooldown, lastAttackTime, zombieLabels, zombieOutlines = {}, 0, {}, {}
local currentMode = "Normal" -- "Normal" æˆ– "Troll" æˆ– "Disguise"ï¼ˆä¼ªè£…æ¨¡å¼ï¼‰
local activeTrollTargets = {}
local trollAttackCooldown = {}
local attackBarrels = true -- æ˜¯å¦æ”»å‡»ç‚¸è¯æ¡¶

-- å½“å‰æ­¦å™¨çš„æ”»å‡»å‚æ•°ï¼ˆæ ¹æ®è£…å¤‡è‡ªåŠ¨è®¾ç½®ï¼‰
local currentAttackRange, currentAimRange, currentMaxTargetsPerCycle, 
      currentInstantAttackRate, currentHitsPerAttack, currentBarrelPriorityRange

local outlinesParent = Instance.new("Folder")
outlinesParent.Name = "ZombieOutlines_FX"
outlinesParent.Parent = workspace 

-- ==================== UI åˆ›å»º ====================
-- å°†UIæ”¾åœ¨CoreGuiä¸­ï¼Œè¿™æ ·å³ä½¿è§’è‰²æ­»äº¡ä¹Ÿä¸ä¼šé‡ç½®
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "KillAuraUI"
screenGui.Parent = game:GetService("CoreGui") -- ä¿®æ”¹ä¸ºCoreGuiï¼Œè§’è‰²æ­»äº¡ä¸ä¼šæ¶ˆå¤±

-- åˆ›å»ºä¸€ä¸ªå¯æ‹–åŠ¨çš„å®¹å™¨
local dragFrame = Instance.new("Frame")
dragFrame.Name = "DragFrame"
dragFrame.Size = UDim2.new(0, 110, 0, 140) -- è°ƒæ•´å¤§å°ä»¥å®¹çº³ä¸‰ä¸ªæŒ‰é’®
dragFrame.Position = UDim2.new(0, 20, 0, 20)
dragFrame.BackgroundTransparency = 1 -- å®Œå…¨é€æ˜
dragFrame.Active = true -- ä½¿æ¡†æ¶å¯ä»¥æ¥æ”¶è¾“å…¥
dragFrame.Selectable = true
dragFrame.Parent = screenGui

-- æ¨¡å¼åˆ‡æ¢æŒ‰é’®ï¼ˆç¼©å°ï¼‰
local modeButton = Instance.new("TextButton")
modeButton.Name = "ModeToggle"
modeButton.Size = UDim2.new(0, 100, 0, 30) -- ç¼©å°æŒ‰é’®
modeButton.Position = UDim2.new(0, 5, 0, 5) -- åœ¨å®¹å™¨å†…åç§»
modeButton.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
modeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
modeButton.Text = "æ¨¡å¼: æ™®é€š"
modeButton.Font = Enum.Font.GothamBold
modeButton.TextSize = 12 -- ç¼©å°æ–‡å­—
modeButton.BorderSizePixel = 0

-- æ”»å‡»ç‚¸è¯æ¡¶å¼€å…³æŒ‰é’®ï¼ˆç¼©å°ï¼‰
local barrelButton = Instance.new("TextButton")
barrelButton.Name = "BarrelToggle"
barrelButton.Size = UDim2.new(0, 100, 0, 30) -- ç¼©å°æŒ‰é’®
barrelButton.Position = UDim2.new(0, 5, 0, 40) -- æ”¾åœ¨æ¨¡å¼æŒ‰é’®ä¸‹æ–¹
barrelButton.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
barrelButton.TextColor3 = Color3.fromRGB(255, 255, 255)
barrelButton.Text = "ç‚¸æ¡¶: å¼€"
barrelButton.Font = Enum.Font.GothamBold
barrelButton.TextSize = 12 -- ç¼©å°æ–‡å­—
barrelButton.BorderSizePixel = 0

-- ä¼ªè£…æ¨¡å¼æŒ‰é’®ï¼ˆæ–°å¢ï¼‰
local disguiseButton = Instance.new("TextButton")
disguiseButton.Name = "DisguiseToggle"
disguiseButton.Size = UDim2.new(0, 100, 0, 30) -- ç¼©å°æŒ‰é’®
disguiseButton.Position = UDim2.new(0, 5, 0, 75) -- æ”¾åœ¨ç‚¸è¯æ¡¶æŒ‰é’®ä¸‹æ–¹
disguiseButton.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
disguiseButton.TextColor3 = Color3.fromRGB(255, 255, 255)
disguiseButton.Text = "ä¼ªè£…æ¨¡å¼: å…³"
disguiseButton.Font = Enum.Font.GothamBold
disguiseButton.TextSize = 12 -- ç¼©å°æ–‡å­—
disguiseButton.BorderSizePixel = 0

-- åˆ›å»ºåœ†è§’æ•ˆæœ
local function applyButtonStyles(button)
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 6) -- ç¨å¾®ç¼©å°åœ†è§’
    corner.Parent = button
    
    local stroke = Instance.new("UIStroke")
    stroke.Color = Color3.fromRGB(100, 100, 100)
    stroke.Thickness = 1.5 -- ç¨å¾®ç¼©å°è¾¹æ¡†
    stroke.Parent = button
    
    return button
end

modeButton = applyButtonStyles(modeButton)
barrelButton = applyButtonStyles(barrelButton)
disguiseButton = applyButtonStyles(disguiseButton)

modeButton.Parent = dragFrame
barrelButton.Parent = dragFrame
disguiseButton.Parent = dragFrame

-- ==================== å±å¹•æç¤ºæ–‡å­— ====================
local noticeLabel = Instance.new("TextLabel")
noticeLabel.Name = "NoticeLabel"
noticeLabel.Size = UDim2.new(0.6, 0, 0, 50)
noticeLabel.Position = UDim2.new(0.2, 0, 0, 10) -- å±å¹•ä¸­é—´ä¸Šæ–¹
noticeLabel.BackgroundTransparency = 0.8
noticeLabel.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
noticeLabel.TextColor3 = Color3.fromRGB(255, 255, 0)
noticeLabel.Text = "ä»…ä¾›æµ‹è¯•ç‰ˆ æœ‰bugè¯·åé¦ˆ\nç›®å‰åªæ”¯æŒ4ç§è¿‘æˆ˜æ­¦å™¨ åç»­å°†æ·»åŠ æ›´å¤š"
noticeLabel.Font = Enum.Font.GothamBold
noticeLabel.TextSize = 14
noticeLabel.TextStrokeTransparency = 0.7
noticeLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
noticeLabel.TextWrapped = true
noticeLabel.Visible = true -- é»˜è®¤æ˜¾ç¤º
noticeLabel.Parent = screenGui

-- æ·»åŠ å…³é—­æç¤ºçš„æŒ‰é’®
local closeNoticeButton = Instance.new("TextButton")
closeNoticeButton.Name = "CloseNoticeButton"
closeNoticeButton.Size = UDim2.new(0, 20, 0, 20)
closeNoticeButton.Position = UDim2.new(0.8, 5, 0, 15)
closeNoticeButton.BackgroundColor3 = Color3.fromRGB(255, 50, 50)
closeNoticeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
closeNoticeButton.Text = "X"
closeNoticeButton.Font = Enum.Font.GothamBold
closeNoticeButton.TextSize = 14
closeNoticeButton.Parent = noticeLabel

local noticeCorner = Instance.new("UICorner")
noticeCorner.CornerRadius = UDim.new(0, 8)
noticeCorner.Parent = noticeLabel

closeNoticeButton.MouseButton1Click:Connect(function()
    noticeLabel.Visible = false
end)

-- ==================== UIæ‹–åŠ¨åŠŸèƒ½ ====================
local dragging = false
local dragInput, dragStart, startPos

-- é¼ æ ‡/è§¦æ‘¸è¾“å…¥è¿æ¥
local function updateDrag(input)
    if not dragging then return end
    
    local delta = input.Position - dragStart
    dragFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
end

-- å¼€å§‹æ‹–åŠ¨
dragFrame.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = dragFrame.Position
        
        -- æ•è·æ‹–åŠ¨æ—¶çš„è¾“å…¥
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

-- æ‹–åŠ¨ä¸­
dragFrame.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
        dragInput = input
    end
end)

-- æ›´æ–°ä½ç½®
UserInputService.InputChanged:Connect(function(input)
    if input == dragInput and dragging then
        updateDrag(input)
    end
end)

-- ==================== æŒ‰é’®ç‚¹å‡»äº‹ä»¶ ====================
modeButton.MouseButton1Click:Connect(function()
    if currentMode == "Normal" then
        currentMode = "Troll"
        modeButton.Text = "æ¨¡å¼: æ¶æ"
        modeButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
    elseif currentMode == "Troll" then
        currentMode = "Normal"
        modeButton.Text = "æ¨¡å¼: æ™®é€š"
        modeButton.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    elseif currentMode == "Disguise" then
        currentMode = "Troll"
        modeButton.Text = "æ¨¡å¼: æ¶æ"
        modeButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
    end
end)

barrelButton.MouseButton1Click:Connect(function()
    attackBarrels = not attackBarrels
    if attackBarrels then
        barrelButton.Text = "ç‚¸æ¡¶: å¼€"
        barrelButton.BackgroundColor3 = Color3.fromRGB(50, 200, 50)
    else
        barrelButton.Text = "ç‚¸æ¡¶: å…³"
        barrelButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
    end
end)

disguiseButton.MouseButton1Click:Connect(function()
    if currentMode == "Disguise" then
        currentMode = "Normal"
        disguiseButton.Text = "ä¼ªè£…: å…³"
        disguiseButton.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
        modeButton.Text = "æ¨¡å¼: æ™®é€š"
        modeButton.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    else
        currentMode = "Disguise"
        disguiseButton.Text = "ä¼ªè£…: å¼€"
        disguiseButton.BackgroundColor3 = Color3.fromRGB(100, 50, 200) -- ç´«è‰²è¡¨ç¤ºä¼ªè£…æ¨¡å¼
        modeButton.Text = "æ¨¡å¼: ä¼ªè£…"
        modeButton.BackgroundColor3 = Color3.fromRGB(100, 50, 200)
    end
end)

-- æŒ‰é’®æ‚¬åœæ•ˆæœ
local function setupButtonHover(button)
    button.MouseEnter:Connect(function()
        local tweenInfo = TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
        local tween = TweenService:Create(button, tweenInfo, {BackgroundTransparency = 0.2})
        tween:Play()
    end)
    
    button.MouseLeave:Connect(function()
        local tweenInfo = TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
        local tween = TweenService:Create(button, tweenInfo, {BackgroundTransparency = 0})
        tween:Play()
    end)
end

setupButtonHover(modeButton)
setupButtonHover(barrelButton)
setupButtonHover(disguiseButton)

-- ==================== æ ¸å¿ƒå‡½æ•° ====================

local function getZombieType(zombieModel)
    local zombieType = zombieModel:GetAttribute("Type")
    if not zombieType then
        local name = zombieModel.Name
        if name:find("Barrel") then return "Barrel"
        elseif name:find("Fast") then return "Fast"
        elseif name:find("Igniter") then return "Igniter"
        elseif name:find("Sapper") then return "Sapper"
        else return "Normal" end
    end
    return zombieType
end

local function getAllZombies()
    local zombies = {}
    for _, folderName in ipairs(zombieFolders) do
        local folder = workspace:FindFirstChild(folderName)
        if folder then
            for _, zombie in ipairs(folder:GetChildren()) do
                if zombie:IsA("Model") and zombie:FindFirstChildOfClass("Humanoid", true) then
                     table.insert(zombies, zombie)
                end
            end
        end
    end
    return zombies
end

local function getAllPlayers()
    local players = {}
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= lp and player.Character then
            local character = player.Character
            local hrp = character:FindFirstChild("HumanoidRootPart")
            if hrp then
                table.insert(players, {
                    character = character,
                    hrp = hrp,
                    name = player.Name
                })
            end
        end
    end
    return players
end

local function isAttackableZombie(zombieModel)
    local zombieType = getZombieType(zombieModel)
    local typeInfo = zombieTypes[zombieType] or zombieTypes["Normal"]
    
    -- å¦‚æœåƒµå°¸æ˜¯ç‚¸è¯æ¡¶ä¸”æ”»å‡»ç‚¸è¯æ¡¶å¼€å…³å…³é—­ï¼Œåˆ™ä¸æ”»å‡»
    if zombieType == "Barrel" and not attackBarrels then
        return false
    end
    
    return typeInfo.attack
end

local function checkWeaponEquipped()
    if not char then 
        isWeaponActuallyEquipped = false
        currentWeapon, currentWeaponConfig = nil, nil
        return false 
    end
    
    for weaponName, config in pairs(weapons) do
        local weaponInChar = char:FindFirstChild(weaponName)
        if weaponInChar then
            currentWeapon, currentWeaponConfig = weaponInChar, config
            isWeaponActuallyEquipped = true
            
            -- è®¾ç½®å½“å‰æ­¦å™¨çš„æ”»å‡»å‚æ•°
            currentAttackRange = config.attackRange or GLOBAL_DEFAULTS.ATTACK_RANGE
            currentAimRange = config.aimRange or GLOBAL_DEFAULTS.AIM_RANGE
            currentMaxTargetsPerCycle = config.maxTargetsPerCycle or GLOBAL_DEFAULTS.MAX_TARGETS_PER_CYCLE
            currentInstantAttackRate = config.instantAttackRate or GLOBAL_DEFAULTS.INSTANT_ATTACK_RATE
            currentHitsPerAttack = config.hitsPerAttack or GLOBAL_DEFAULTS.HITS_PER_ATTACK
            currentBarrelPriorityRange = config.barrelPriorityRange or GLOBAL_DEFAULTS.BARREL_PRIORITY_RANGE
            
            return true
        end
    end
    
    isWeaponActuallyEquipped = false
    currentWeapon, currentWeaponConfig = nil, nil
    return false
end

local function getRemote()
    return currentWeapon and currentWeaponConfig and currentWeapon:FindFirstChild(currentWeaponConfig.remotePath)
end

local function aimAtTarget(targetPos)
    if not root then return end
    local direction = (targetPos - root.Position).Unit
    root.CFrame = CFrame.lookAt(root.Position, root.Position + Vector3.new(direction.X, 0, direction.Z))
end

-- ==================== ç›®æ ‡è·å–å‡½æ•°ï¼ˆæ ¹æ®æ¨¡å¼ï¼‰ ====================

local function getNormalModeTargets()
    local targets = {}
    local barrelTargets = {}
    
    for _, zombie in ipairs(getAllZombies()) do
        if not isAttackableZombie(zombie) then continue end
        
        local headPart = zombie:FindFirstChild("Head", true)
        local targetPart = headPart or zombie:FindFirstChild("HumanoidRootPart", true)
        
        if targetPart and targetPart:IsA("BasePart") then
            local hrp = zombie:FindFirstChild("HumanoidRootPart", true)
            if not hrp then continue end 
            
            local headSizeZ = targetPart.Size.Z
            local hrpLookVector = hrp.CFrame.LookVector
            
            local attackPosition = targetPart.Position - hrpLookVector * (headSizeZ / 2 * 1.05)
            
            local distance = (root.Position - attackPosition).Magnitude
            
            if distance <= currentAttackRange then
                local zombieType = getZombieType(zombie)
                local typeInfo = zombieTypes[zombieType] or zombieTypes["Normal"]
                
                local targetData = {
                    model = zombie,
                    part = targetPart,
                    position = attackPosition, 
                    distance = distance,
                    isHead = (targetPart == headPart),
                    zombieType = zombieType,
                    priority = typeInfo.priority or 1
                }
                
                if zombieType == "Barrel" and distance <= currentBarrelPriorityRange then
                    table.insert(barrelTargets, targetData)
                else
                    table.insert(targets, targetData)
                end
            end
        end
    end
    
    table.sort(barrelTargets, function(a, b) return a.distance < b.distance end)
    table.sort(targets, function(a, b) 
        if a.priority ~= b.priority then
            return a.priority > b.priority
        else
            return a.distance < b.distance
        end
    end)
    
    for _, barrelTarget in ipairs(barrelTargets) do
        table.insert(targets, 1, barrelTarget)
    end
    
    return targets
end

local function getTrollModeTargets()
    local targets = {}
    local barrelTargets = {}
    local allPlayers = getAllPlayers()
    
    for _, zombie in ipairs(getAllZombies()) do
        if not isAttackableZombie(zombie) then continue end
        
        local headPart = zombie:FindFirstChild("Head", true)
        local targetPart = headPart or zombie:FindFirstChild("HumanoidRootPart", true)
        
        if targetPart and targetPart:IsA("BasePart") then
            local hrp = zombie:FindFirstChild("HumanoidRootPart", true)
            if not hrp then continue end 
            
            local headSizeZ = targetPart.Size.Z
            local hrpLookVector = hrp.CFrame.LookVector
            
            local attackPosition = targetPart.Position - hrpLookVector * (headSizeZ / 2 * 1.05)
            
            local distance = (root.Position - attackPosition).Magnitude
            
            if distance <= currentAttackRange then
                local zombieType = getZombieType(zombie)
                local typeInfo = zombieTypes[zombieType] or zombieTypes["Normal"]
                
                local targetData = {
                    model = zombie,
                    part = targetPart,
                    position = attackPosition, 
                    distance = distance,
                    isHead = (targetPart == headPart),
                    zombieType = zombieType,
                    priority = typeInfo.priority or 1
                }
                
                -- åœ¨æ¶ææ¨¡å¼ä¸‹ï¼Œè‡ªçˆ†åƒµå°¸éœ€è¦ç‰¹æ®Šå¤„ç†
                if zombieType == "Barrel" then
                    -- æ£€æŸ¥æ˜¯å¦æœ‰é˜Ÿå‹åœ¨è‡ªçˆ†åƒµå°¸é™„è¿‘ (7.9ç±³èŒƒå›´å†…)
                    local hasNearbyPlayer = false
                    for _, playerData in ipairs(allPlayers) do
                        local playerToZombieDistance = (playerData.hrp.Position - hrp.Position).Magnitude
                        if playerToZombieDistance <= GLOBAL_DEFAULTS.TROLL_MODE_RANGE then
                            hasNearbyPlayer = true
                            break
                        end
                    end
                    
                    -- åªæœ‰å½“æœ‰é˜Ÿå‹é è¿‘æ—¶æ‰æ”»å‡»è‡ªçˆ†åƒµå°¸
                    if hasNearbyPlayer and distance <= currentBarrelPriorityRange then
                        table.insert(barrelTargets, targetData)
                    end
                    -- å¦‚æœæ²¡æœ‰é˜Ÿå‹é è¿‘ï¼Œå°±ä¸æ”»å‡»è‡ªçˆ†åƒµå°¸
                else
                    -- å…¶ä»–åƒµå°¸æ­£å¸¸æ”»å‡»
                    table.insert(targets, targetData)
                end
            end
        end
    end
    
    table.sort(barrelTargets, function(a, b) return a.distance < b.distance end)
    table.sort(targets, function(a, b) 
        if a.priority ~= b.priority then
            return a.priority > b.priority
        else
            return a.distance < b.distance
        end
    end)
    
    for _, barrelTarget in ipairs(barrelTargets) do
        table.insert(targets, 1, barrelTarget)
    end
    
    return targets
end

local function getDisguiseModeTargets()
    local targets = {}
    local allPlayers = getAllPlayers()
    
    for _, zombie in ipairs(getAllZombies()) do
        -- ä¼ªè£…æ¨¡å¼ä¸‹åªæ”»å‡»ç‚¸è¯æ¡¶åƒµå°¸
        local zombieType = getZombieType(zombie)
        if zombieType ~= "Barrel" then continue end
        
        local headPart = zombie:FindFirstChild("Head", true)
        local targetPart = headPart or zombie:FindFirstChild("HumanoidRootPart", true)
        
        if targetPart and targetPart:IsA("BasePart") then
            local hrp = zombie:FindFirstChild("HumanoidRootPart", true)
            if not hrp then continue end 
            
            local headSizeZ = targetPart.Size.Z
            local hrpLookVector = hrp.CFrame.LookVector
            
            local attackPosition = targetPart.Position - hrpLookVector * (headSizeZ / 2 * 1.05)
            
            local distance = (root.Position - attackPosition).Magnitude
            
            if distance <= currentAttackRange then
                local typeInfo = zombieTypes[zombieType] or zombieTypes["Normal"]
                
                local targetData = {
                    model = zombie,
                    part = targetPart,
                    position = attackPosition, 
                    distance = distance,
                    isHead = (targetPart == headPart),
                    zombieType = zombieType,
                    priority = typeInfo.priority or 1
                }
                
                -- æ£€æŸ¥æ˜¯å¦æœ‰é˜Ÿå‹åœ¨è‡ªçˆ†åƒµå°¸é™„è¿‘ (7.9ç±³èŒƒå›´å†…)
                local hasNearbyPlayer = false
                for _, playerData in ipairs(allPlayers) do
                    local playerToZombieDistance = (playerData.hrp.Position - hrp.Position).Magnitude
                    if playerToZombieDistance <= GLOBAL_DEFAULTS.TROLL_MODE_RANGE then
                        hasNearbyPlayer = true
                        break
                    end
                end
                
                -- åªæœ‰å½“æœ‰é˜Ÿå‹é è¿‘æ—¶æ‰æ”»å‡»è‡ªçˆ†åƒµå°¸
                if hasNearbyPlayer and distance <= currentBarrelPriorityRange then
                    table.insert(targets, targetData)
                end
            end
        end
    end
    
    table.sort(targets, function(a, b) return a.distance < b.distance end)
    
    return targets
end

local function getTargets()
    if currentMode == "Troll" then
        return getTrollModeTargets()
    elseif currentMode == "Disguise" then
        return getDisguiseModeTargets()
    else
        return getNormalModeTargets()
    end
end

-- ==================== æ”»å‡»å‡½æ•° ====================

local function attackWithSpontoon(target)
    if not humanoid or not humanoid.Parent then return end 
    
    local id = target.model:GetDebugId()
    if attackCooldown[id] and tick() - attackCooldown[id] < 0.05 then return end
    
    local remote = getRemote()
    if not remote then return end
    
    if target.distance <= currentAimRange then aimAtTarget(target.position) end
    
    humanoid.Sit = false 
    humanoid:ChangeState(Enum.HumanoidStateType.Running) 
    
    -- ä½¿ç”¨å½“å‰æ­¦å™¨çš„æ”»å‡»æ¬¡æ•°
    for hit = 1, currentHitsPerAttack do
        for i = 1, 2 do
            remote:FireServer("Equip", root)
            remote:FireServer("PrepareSwing")
            remote:FireServer("Swing", "Thrust")
            remote:FireServer("HitZombie", target.model, target.position, false, Vector3.zero, target.part.Name, Vector3.new(0,1,0))
        end
    end
    
    attackCooldown[id] = tick()
end

local function attackWithOtherWeapon(target)
    if not humanoid or not humanoid.Parent then return end 
    
    local id = target.model:GetDebugId()
    if attackCooldown[id] and tick() - attackCooldown[id] < 0.05 then return end
    
    local remote = getRemote()
    if not remote then return end
    
    if target.distance <= currentAimRange then aimAtTarget(target.position) end
    
    humanoid.Sit = false 
    humanoid:ChangeState(Enum.HumanoidStateType.Running) 
    
    -- ä½¿ç”¨å½“å‰æ­¦å™¨çš„æ”»å‡»æ¬¡æ•°
    for hit = 1, currentHitsPerAttack do
        remote:FireServer("Equip", root)
        remote:FireServer("PrepareSwing")
        remote:FireServer("Swing", currentWeaponConfig.attackType)
        remote:FireServer("HitZombie", target.model, target.position, false, Vector3.zero, target.part.Name, Vector3.new(0,1,0))
    end
    
    attackCooldown[id] = tick()
end

local function rapidHit(target)
    if not humanoid or not humanoid.Parent then return end 
    
    local id = target.model:GetDebugId()
    if attackCooldown[id] and tick() - attackCooldown[id] < 0.05 then return end
    
    local remote = getRemote()
    if not remote then return end
    
    if target.distance <= currentAimRange then aimAtTarget(target.position) end
    
    humanoid.Sit = false 
    humanoid:ChangeState(Enum.HumanoidStateType.Running) 
    
    if currentWeapon and currentWeapon.Name == "Spontoon" then
        attackWithSpontoon(target)
    else
        attackWithOtherWeapon(target)
    end
    
    attackCooldown[id] = tick()
end

local function continuousAttack()
    if not isWeaponActuallyEquipped then return end 
    
    local targets = getTargets()
    for i = 1, math.min(#targets, currentMaxTargetsPerCycle) do
        rapidHit(targets[i])
    end
end

-- ==================== è§†è§‰ç³»ç»Ÿå‡½æ•° ====================

local function createWorldLabel(zombieModel)
    if zombieLabels[zombieModel] then return zombieLabels[zombieModel] end
    
    local zombieType = getZombieType(zombieModel)
    local typeInfo = zombieTypes[zombieType] or zombieTypes["Normal"]
    local adornee = zombieModel:FindFirstChild("Head", true) or zombieModel:FindFirstChild("HumanoidRootPart", true)
    
    if not adornee then return nil end
    
    local billboard = Instance.new("BillboardGui")
    billboard.Name = "WorldLabel"
    billboard.Adornee = adornee
    billboard.Size = LABEL_SETTINGS.Size
    billboard.StudsOffset = LABEL_SETTINGS.StudsOffset
    billboard.AlwaysOnTop = true 
    billboard.MaxDistance = MAX_DISPLAY_DISTANCE
    billboard.Parent = zombieModel
    
    local textLabel = Instance.new("TextLabel")
    textLabel.Size = UDim2.new(1, 0, 1, 0)
    textLabel.BackgroundTransparency = 1
    textLabel.Text = typeInfo.name
    textLabel.TextColor3 = typeInfo.color
    textLabel.TextScaled = false
    textLabel.TextSize = LABEL_SETTINGS.TextSize
    textLabel.Font = Enum.Font.GothamBold
    textLabel.TextStrokeTransparency = 1
    textLabel.Parent = billboard
    
    zombieLabels[zombieModel] = {billboard = billboard, textLabel = textLabel, adornee = adornee}
    return zombieLabels[zombieModel]
end

local function updateZombieLabel(zombieModel)
    local labelInfo = zombieLabels[zombieModel]
    if not labelInfo or not root or not labelInfo.adornee then return end
    
    local zombieType = getZombieType(zombieModel)
    local typeInfo = zombieTypes[zombieType] or zombieTypes["Normal"]
    local distance = (root.Position - labelInfo.adornee.Position).Magnitude
    
    labelInfo.textLabel.Text = typeInfo.name .. " [" .. math.floor(distance) .. "m]"
    labelInfo.billboard.Enabled = distance <= MAX_DISPLAY_DISTANCE
end

local function createZombieOutline(zombieModel)
    if zombieOutlines[zombieModel] then
        if zombieOutlines[zombieModel].connection and typeof(zombieOutlines[zombieModel].connection) == "RBXScriptConnection" then
            zombieOutlines[zombieModel].connection:Disconnect()
        end
        
        if zombieOutlines[zombieModel].parts then
            for _, part in ipairs(zombieOutlines[zombieModel].parts) do
                if part and part.Parent then
                    part:Destroy()
                end
            end
        end
        zombieOutlines[zombieModel] = nil
    end

    local zombieType = getZombieType(zombieModel)
    local typeInfo = zombieTypes[zombieType] or zombieTypes["Normal"]
    local color = typeInfo.color
    
    local brightColor = Color3.new(
        math.min(color.R * OUTLINE_SETTINGS.ColorMultiplier, 1),
        math.min(color.G * OUTLINE_SETTINGS.ColorMultiplier, 1),
        math.min(color.B * OUTLINE_SETTINGS.ColorMultiplier, 1)
    )
    
    local outlineParts = {}
    
    for _, partName in ipairs(zombieBodyParts) do
        local bodyPart = zombieModel:FindFirstChild(partName, true) 
        if bodyPart and bodyPart:IsA("BasePart") then
            local outlinePart = Instance.new("Part")
            outlinePart.Name = "ZombieOutline_" .. partName
            outlinePart.Anchored = true
            outlinePart.CanCollide = false
            outlinePart.Material = OUTLINE_SETTINGS.Material
            outlinePart.BrickColor = BrickColor.new(brightColor)
            outlinePart.Transparency = OUTLINE_SETTINGS.Transparency
            outlinePart.Size = bodyPart.Size * OUTLINE_SETTINGS.SizeMultiplier
            outlinePart.CFrame = bodyPart.CFrame
            outlinePart.Parent = outlinesParent 
            table.insert(outlineParts, outlinePart)
        end
    end
    
    if #outlineParts == 0 then 
        local hrp = zombieModel:FindFirstChild("HumanoidRootPart", true)
        if hrp then
            local outlinePart = Instance.new("Part")
            outlinePart.Name = "ZombieOutline_Default"
            outlinePart.Anchored = true
            outlinePart.CanCollide = false
            outlinePart.Material = OUTLINE_SETTINGS.Material
            outlinePart.BrickColor = BrickColor.new(brightColor)
            outlinePart.Transparency = OUTLINE_SETTINGS.Transparency
            outlinePart.Size = Vector3.new(4, 6, 2) * OUTLINE_SETTINGS.SizeMultiplier
            outlinePart.CFrame = hrp.CFrame
            outlinePart.Parent = outlinesParent
            table.insert(outlineParts, outlinePart)
        end
    end

    if #outlineParts == 0 then return nil end
    
    local connection = RS.Heartbeat:Connect(function()
        if zombieModel.Parent and zombieModel:FindFirstChildOfClass("Humanoid", true) then
            local allPartsStillExist = true
            for i = #outlineParts, 1, -1 do
                local outlinePart = outlineParts[i]
                if not outlinePart or not outlinePart.Parent then
                    table.remove(outlineParts, i)
                    allPartsStillExist = false
                    continue
                end

                local partName = outlinePart.Name:gsub("ZombieOutline_", "")
                local bodyPart = zombieModel:FindFirstChild(partName, true) 

                if bodyPart and bodyPart.Parent then
                    outlinePart.Size = bodyPart.Size * OUTLINE_SETTINGS.SizeMultiplier
                    outlinePart.CFrame = bodyPart.CFrame
                elseif partName == "Default" then
                    local hrp = zombieModel:FindFirstChild("HumanoidRootPart", true)
                    if hrp and hrp.Parent then 
                        outlinePart.CFrame = hrp.CFrame 
                    end
                else
                    if outlinePart.Parent then
                        outlinePart:Destroy()
                    end
                    table.remove(outlineParts, i)
                    allPartsStillExist = false
                end
            end
            if not allPartsStillExist and #outlineParts == 0 then
                if connection and typeof(connection) == "RBXScriptConnection" then
                    connection:Disconnect()
                end
                zombieOutlines[zombieModel] = nil
            end

        else
            if connection and typeof(connection) == "RBXScriptConnection" then
                connection:Disconnect()
            end
            for _, part in ipairs(outlineParts) do
                if part and part.Parent then 
                    Debris:AddItem(part, 0) 
                end
            end
            zombieOutlines[zombieModel] = nil
        end
    end)
    
    zombieOutlines[zombieModel] = {parts = outlineParts, connection = connection}
    return zombieOutlines[zombieModel]
end

local function updateZombieVisuals()
    local currentZombies = {}
    local allZombies = getAllZombies()

    for _, zombie in ipairs(allZombies) do
        currentZombies[zombie] = true
        createWorldLabel(zombie)
        updateZombieLabel(zombie)
        createZombieOutline(zombie)
    end
    
    for zombieModel, labelInfo in pairs(zombieLabels) do
        if not currentZombies[zombieModel] then
            if labelInfo and labelInfo.billboard and labelInfo.billboard.Parent then
                Debris:AddItem(labelInfo.billboard, 0)
            end
            zombieLabels[zombieModel] = nil
        end
    end
    
    for zombieModel, outlineInfo in pairs(zombieOutlines) do
        if not currentZombies[zombieModel] then
            if outlineInfo and outlineInfo.connection and typeof(outlineInfo.connection) == "RBXScriptConnection" then
                outlineInfo.connection:Disconnect()
            end
            if outlineInfo and outlineInfo.parts then
                for _, part in ipairs(outlineInfo.parts) do
                    if part and part.Parent then Debris:AddItem(part, 0) end
                end
            end
            zombieOutlines[zombieModel] = nil
        end
    end
end

-- ==================== ç³»ç»Ÿå¾ªç¯ ====================
task.spawn(function()
    while true do
        task.wait(0.1)
        local currentTime = tick()
        for id, time in pairs(attackCooldown) do
            if currentTime - time > 0.1 then attackCooldown[id] = nil end
        end
    end
end)

task.spawn(function()
    while true do
        updateZombieVisuals()
        task.wait(0.1)
    end
end)

task.spawn(function()
    while true do
        checkWeaponEquipped()
        task.wait(0.1)
    end
end)

RS.Heartbeat:Connect(function()
    if not isWeaponActuallyEquipped then return end
    
    local currentTime = tick()
    if currentTime - lastAttackTime >= currentInstantAttackRate then
        continuousAttack()
        lastAttackTime = currentTime
    end
end)

local function onCharacterAdded(newChar)
    char = newChar
    root = char:WaitForChild("HumanoidRootPart")
    humanoid = char:WaitForChild("Humanoid") 
    isWeaponActuallyEquipped = false
    currentWeapon, currentWeaponConfig = nil, nil
    
    for zombieModel, labelInfo in pairs(zombieLabels) do
        if labelInfo and labelInfo.billboard and labelInfo.billboard.Parent then 
            Debris:AddItem(labelInfo.billboard, 0) 
        end
        zombieLabels[zombieModel] = nil
    end
    
    for zombieModel, outlineInfo in pairs(zombieOutlines) do
        if outlineInfo and outlineInfo.connection and typeof(outlineInfo.connection) == "RBXScriptConnection" then
            outlineInfo.connection:Disconnect()
        end
        if outlineInfo and outlineInfo.parts then
            for _, part in ipairs(outlineInfo.parts) do
                if part and part.Parent then 
                    Debris:AddItem(part, 0) 
                end
            end
        end
        zombieOutlines[zombieModel] = nil
    end
    
    zombieLabels, zombieOutlines = {}, {}
    for _, child in ipairs(outlinesParent:GetChildren()) do
        if child:IsA("Part") and child.Name:find("ZombieOutline_") then 
            Debris:AddItem(child, 0) 
        end
    end

    task.wait(1)
end

lp.CharacterAdded:Connect(onCharacterAdded)
